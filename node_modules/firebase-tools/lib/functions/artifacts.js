"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.hasCleanupOptOut = exports.hasSameCleanupPolicy = exports.setCleanupPolicy = exports.optOutRepository = exports.updateRepository = exports.generateCleanupPolicy = exports.parseDaysFromPolicy = exports.daysToSeconds = exports.findExistingPolicy = exports.makeRepoPath = exports.DEFAULT_CLEANUP_DAYS = exports.OPT_OUT_LABEL_KEY = exports.CLEANUP_POLICY_ID = exports.GCF_REPO_ID = void 0;
const artifactregistry = require("../gcp/artifactregistry");
const error_1 = require("../error");
exports.GCF_REPO_ID = "gcf-artifacts";
exports.CLEANUP_POLICY_ID = "firebase-functions-cleanup";
exports.OPT_OUT_LABEL_KEY = "firebase-functions-cleanup-opted-out";
exports.DEFAULT_CLEANUP_DAYS = 1;
const SECONDS_IN_DAY = 24 * 60 * 60;
function makeRepoPath(projectId, location, repoName = exports.GCF_REPO_ID) {
    return `projects/${projectId}/locations/${location}/repositories/${repoName}`;
}
exports.makeRepoPath = makeRepoPath;
function findExistingPolicy(repository) {
    var _a;
    return (_a = repository === null || repository === void 0 ? void 0 : repository.cleanupPolicies) === null || _a === void 0 ? void 0 : _a[exports.CLEANUP_POLICY_ID];
}
exports.findExistingPolicy = findExistingPolicy;
function daysToSeconds(days) {
    const seconds = days * SECONDS_IN_DAY;
    return `${seconds}s`;
}
exports.daysToSeconds = daysToSeconds;
function parseDaysFromPolicy(olderThan) {
    const match = olderThan.match(/^(\d+)s$/);
    if (match && match[1]) {
        const seconds = parseInt(match[1], 10);
        return Math.floor(seconds / SECONDS_IN_DAY);
    }
    return;
}
exports.parseDaysFromPolicy = parseDaysFromPolicy;
function generateCleanupPolicy(daysToKeep) {
    return {
        [exports.CLEANUP_POLICY_ID]: {
            id: exports.CLEANUP_POLICY_ID,
            condition: {
                tagState: "ANY",
                olderThan: daysToSeconds(daysToKeep),
            },
            action: "DELETE",
        },
    };
}
exports.generateCleanupPolicy = generateCleanupPolicy;
async function updateRepository(repo) {
    try {
        await artifactregistry.updateRepository(repo);
    }
    catch (err) {
        if (err.status === 403) {
            throw new error_1.FirebaseError(`You don't have permission to update this repository.\n` +
                `To update repository settings, ask your administrator to grant you the ` +
                `Artifact Registry Administrator (roles/artifactregistry.admin) IAM role on the repository project.`, { original: err, exit: 1 });
        }
        else {
            throw new error_1.FirebaseError("Failed to update artifact registry repository", {
                original: err,
            });
        }
    }
}
exports.updateRepository = updateRepository;
async function optOutRepository(repository) {
    const policies = Object.assign({}, repository.cleanupPolicies);
    if (exports.CLEANUP_POLICY_ID in policies) {
        delete policies[exports.CLEANUP_POLICY_ID];
    }
    const update = {
        name: repository.name,
        labels: Object.assign(Object.assign({}, repository.labels), { [exports.OPT_OUT_LABEL_KEY]: "true" }),
        cleanupPolicies: policies,
    };
    await exports.updateRepository(update);
}
exports.optOutRepository = optOutRepository;
async function setCleanupPolicy(repository, daysToKeep) {
    const labels = Object.assign({}, repository.labels);
    delete labels[exports.OPT_OUT_LABEL_KEY];
    const update = {
        name: repository.name,
        cleanupPolicies: Object.assign(Object.assign({}, repository.cleanupPolicies), generateCleanupPolicy(daysToKeep)),
        labels,
    };
    await exports.updateRepository(update);
}
exports.setCleanupPolicy = setCleanupPolicy;
function hasSameCleanupPolicy(repository, daysToKeep) {
    var _a, _b;
    const existingPolicy = findExistingPolicy(repository);
    if (!existingPolicy) {
        return false;
    }
    if (((_a = existingPolicy.condition) === null || _a === void 0 ? void 0 : _a.tagState) !== "ANY" || !((_b = existingPolicy.condition) === null || _b === void 0 ? void 0 : _b.olderThan)) {
        return false;
    }
    const existingSeconds = parseDaysFromPolicy(existingPolicy.condition.olderThan);
    return existingSeconds === daysToKeep;
}
exports.hasSameCleanupPolicy = hasSameCleanupPolicy;
function hasCleanupOptOut(repo) {
    return !!(repo.labels && repo.labels[exports.OPT_OUT_LABEL_KEY] === "true");
}
exports.hasCleanupOptOut = hasCleanupOptOut;
